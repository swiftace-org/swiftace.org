# How to Deploy a Web App to a Cloud VM

Let's walk through the process of deploying a web application to a Linux-based cloud virtual machine (VM). Along the way, we'll also discuss best practices for ensuring the security and reliability of your app. Basic knowledge of Linux and command line tools is assumed here<sup>[[1]](#note-1)</sup>.

Here are the steps we'll follow:

1. Create an SSH key pair to securely access and operate a cloud VM
2. Rent a Linux-based cloud VM and assign a public IP address to it
3. Configure DNS records for a domain name so it points the rented VM
4. Log in to the VM remotely using SSH and execute shell commands
5. Download source code and prepare the production build for a web app
6. Run the web app as a system service with auto-restart on crash/reboot
7. Set up a network firewall to block undesired traffic on non-HTTP ports
8. Configure a reverse proxy to serve the web app securely over HTTPS

TODO - first follow along with the steps provided to get a feel for it, and then repeat it and make the necessary chagnes for your own project. Use ChatGPT or Claude to debug errors.

## 1. Create an SSH Key Pair

We'll use a command line tool called [SSH (Secure Shell)](https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys) to access and operate a cloud VM remotely from a local machine (e.g. your laptop). While we could log in to a cloud VM via SSH with just a username and password, using an SSH key pair<sup>[[2]](#note-2)</sup> is a much more secure method.

Let's generate a new SSH key pair on our local machine. Open up a new terminal on Linux, macOS, or [Windows WSL](https://learn.microsoft.com/en-us/windows/wsl/setup/environment) and run the following command (without the `$` at the start):

```bash
$ ssh-keygen -t ed25519 -f ~/.ssh/webapp -C "webapp"
```

_You can replace `webapp` above and hereafter with a more specific name e.g. `my-blog`._

You'll be prompted to enter an optional passphrase to encrypt the private key, adding yet another layer of security. If you set one, you'll be asked to enter it every time you use the key. Let's verify that the key pair was created in the directory `~/.ssh` using the `ls` command:

```bash
$ ls ~/.ssh

webapp  webapp.pub
```

_Two files are created in `~/.ssh`: a private key `webapp`, and a public key `webapp.pub`._

## 2. Rent a Cloud VM

You can rent cloud VMs on platforms like [Hetzner Cloud](https://www.hetzner.com/cloud/) and [DigitalOcean](https://www.digitalocean.com/pricing/droplets) for under $5 per month. Even the cheapest VM on Hetzner (2 CPU cores, 4 GB RAM, and 40 GB disk space) can comfortably supports up to 10,000 daily active users for a typical web application<sup>[[3]](#note-3)</sup>.

While configuring the VM, make sure to enable the assignment of a public IPv4 address<sup>[[4]](#note-4)</sup> and select "SSH Key" as the authentication method (instead of a "root" user password). To add the public key created earlier, first run the following command on your local machine:

```bash
$ cat ~/.ssh/webapp.pub

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIO2TIn2kyfSfBCUlSr6CNgrYTarqEUoCy1gEeC14qqmx webapp
```

Then, copy the result displayed and paste it into the "Add SSH Key" dialog on Hetzner<sup>[[5]](#note-5)</sup>:

![ssh-key](https://i.imgur.com/AYNNoFd.png)

All other settings can be left in their default state (they can be changed later as needed). Once the machine is created and running, copy or note down its public IPv4 address:

![ipv4](https://i.imgur.com/kun3ulM.png)

## 3. Connect a Domain

You can purchase a domain name (e.g. "yourdomain.com") for your web application from domain registrars like [Namecheap](https://www.namecheap.com/), [GoDaddy](godaddy.com/), or [Cloudflare](https://domains.cloudflare.com/). Once purchased, you must add a DNS `A record`<sup>[[6]](#note-6)</sup> to point the domain (or a subdomain) to the IP address of the cloud VM.

![dns-record](https://i.imgur.com/SXIWNLe.png)

Make sure it’s a straight DNS pointer, without a proxy. Also make sure to delete conflicting `A` or `CNAME` records, if any. Check your registrar's website for more detailed instructions. Run the `host` command on your local machine to check if your domain points to the right IP:

```bash
$ host yourdomain.com

yourdomain.com has address 48.13.135.0
```

_Replace `yourdomain.com` above and hereafter with the domain name you've configured._

## 4. SSH into the VM

We've successfully created a cloud VM, added an SSH public key to it, and configured a domain to point to its IP address. We can now log in to the VM via SSH using the private key created earlier. Just run the following command in a terminal on your local machine:

```bash
$ ssh -i ~/.ssh/webapp root@yourdomain.com
```

You'll be presented with the message: `Are you sure you want to continue connecting?`. Type `yes` and press Enter/Return to continue. You're now remotely logged in to the cloud VM as the `root` user, and the `$` prompt changes to `#`. Try executing the `pwd` command:

```bash
# pwd

/root
```

_Use the `exit` command to log out, and run the SSH command shown earlier to log back in._

## 5. Prepare a Web App

You can use the VM to deploy web applications built using any programming language or framework. Let's demonstrate this process for a web app built using [Next.js](https://nextjs.org/), a popular JavaScript framework. First, let's install [Node.js](https://nodejs.org/en) and [npm](https://www.npmjs.com/about) to enable JavaScript execution:

```bash
# apt install nodejs npm
```

Next, let's download the source code for a Next.js project using the `git clone` command:

```bash
# git clone https://github.com/aakashns/nextjs-starter.git webapp
```

If you clone a private repository, you'll be prompted to enter a username and password. If the repository is hosted on GitHub, make sure to enter a [personal access token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic) as the password.

Next, let's enter the project directory, install dependencies, and create a production build:

```bash
# cd webapp && npm install && npm run build
```

_The above commands will differ based on the language and/or web framework you're using._

We can now start the production sever with the `npm start` command. However, to keep the server running even after we log out of the VM, we must set it up as a Linux system service.

## 6. Create a System Service

A [Linux system service](https://lym.readthedocs.io/en/latest/services.html) is a background process that starts during system boot or runs in response to specific triggers. To run our web application as a system service, let's create a file `webapp.service` in the `/etc/systemd/system` directory using the `nano` text editor:

```bash
# nano /etc/systemd/system/webapp.service
```

Paste the following text into the file, then press `Ctrl+O Enter` to save, and `Ctrl+X` to exit:

```ini
[Service]
WorkingDirectory=/root/webapp
ExecStart=/usr/bin/npm start
Restart=always

[Install]
WantedBy=multi-user.target
```

The above minimal configuration creates a service that runs `npm start` inside the directory `/root/webapp` on system boot, and automatically restarts the application if it ever crashes.

Next, run the following command to load the configuration and start the service:

```bash
# systemctl enable --now webapp
```

We can verify that the service is up and running using the `systemctl status` command:

```bash
# systemctl status webapp

● webapp.service
     Loaded: loaded (/etc/systemd/system/webapp.service; enabled; preset: enabled)
     Active: active (running) since Thu 2024-11-14 10:36:50 UTC; 1min 49s ago
   Main PID: 7642 (npm start)
      Tasks: 31 (limit: 4543)
     Memory: 80.8M (peak: 101.0M)
        CPU: 3.057s
     CGroup: /system.slice/webapp.service
             ├─7642 "npm start"
             ├─7657 sh -c "next start"
             └─7658 "next-server (v15.0.3)"

Nov 14 10:36:50 webapp systemd[1]: Started webapp.service.
Nov 14 10:36:51 webapp npm[7642]: > nextjs-starter@0.1.0 start
Nov 14 10:36:51 webapp npm[7642]: > next start
Nov 14 10:36:52 webapp npm[7658]:    ▲ Next.js 15.0.3
Nov 14 10:36:52 webapp npm[7658]:    - Local:        http://localhost:3000
Nov 14 10:36:52 webapp npm[7658]:  ✓ Starting...
Nov 14 10:36:52 webapp npm[7658]:  ✓ Ready in 744ms
```

The Next.js app is listening for HTTP requests on the port 3000 (this may differ based on language/framework). Open the URL http://yourdomain.com:3000 (replace `yourdomain.com` with your actual domain) in a browser on your local machine to access the web application:

![web-app](https://i.imgur.com/LKrrL2t.png)

Use the command `systemctl restart webapp` to manually restart the service when you update the source code, rebuild the application, or make configuration changes. Use the command `journalctl -u webapp.service` to view application logs and error messages.

## 7. Set Up a Network Firewall

TODO - firewall setup instructions

```bash
ufw default deny incoming
ufw default allow outgoing
ufw allow ssh
ufw allow http
ufw allow https
ufw enable
```

Then check the status:

```bash
# ufw status

Status: active

To                         Action      From
--                         ------      ----
22/tcp                     ALLOW       Anywhere
80/tcp                     ALLOW       Anywhere
443                        ALLOW       Anywhere
22/tcp (v6)                ALLOW       Anywhere (v6)
80/tcp (v6)                ALLOW       Anywhere (v6)
443 (v6)                   ALLOW       Anywhere (v6)
```

The system is now locked down, and no toher ports are accessible. You will no longer be able to access the web app at http://yourdomain.com:3000/.

## 8. Reverse Proxy with HTTPS

Let's install a proxy server:

```bash
# apt install caddy
```

Then, edit the caddy file:

```bash
# nano /etc/caddy/Caddyfile
```

Erase the existing contents, and paste the following:

```bash
yourdomain.com {
	reverse_proxy localhost:3000
}
```

Then save it.

Tip: You can add more configs to run multiple web apps.

Now reload the configuration (Caddy is also a system service):

```bash
# systemctl reload caddy
```

Now, navigate to https://yourdomain.com (replace `yourdomain` with your acutal domain) and you should be able to see the web application, served securely over HTTPS. If you try to access it over HTTP, it will automatically redirect to HTTPS.

And that's it, we've done it!

## Troubleshooting

Show common failure cases here

- dns record not working

- lost your private key

- something about docker

## Conclusion

TODO - add summary and conclusion here (talk about maintenance, monitoring etc.)

### Footnotes

1. <a id="note-1"></a> Note 1 - Tutorial for Linux command line

2. <a id="note-2"></a> Note 2 - Talk about SSH key pair

3. <a id="note-3"></a> Note 3 - Show DAU calculation

4. <a id="note-4"></a> Note 4 - Public IPv4 addresses (limited, chargeable)

5. <a id="note-5"></a> SSH key on digital ocean (copy the file to Desktop)

6. <a id="note-6"></a> Talk about DNS A records etc.
